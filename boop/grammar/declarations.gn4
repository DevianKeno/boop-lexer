grammar declarations;

fragment DIGIT: [0-9]+ ;
fragment SPECIAL
    : ' ' | '.'
    ;
    
fragment MATH: 'âˆš'
    ;

fragment ALPHA : [a-z]+ | [A-Z]+ ;
fragment ALNUM : ALPHA | DIGIT ;
fragment SYMBOL : SPECIAL | MATH ;
fragment CHARACTER : ALNUM | SYMBOL ;

// Keywords
ABSTRACT   : 'abstract';
ALIAS      : 'alias';
ASYNC      : 'async';
BASE       : 'base';
BOOL       : 'bool';
BREAK      : 'break';
CASE       : 'case';
CATCH      : 'catch';
CHAR       : 'char';
CLASS      : 'class';
CONST      : 'const';
CONSTANT   : 'constant';
CONTINUE   : 'continue';
DEFAULT    : 'default';
DELAYED    : 'delayed';
DICT       : 'dict';
DICTIONARY : 'dictionary';
DO         : 'do';
DOUBLE     : 'double';
ELSE       : 'else';
ENUM       : 'enum';
ENUMERATION: 'enumeration';
EVENT      : 'event';
FALSE      : 'false';
FLOAT      : 'float';
FOR        : 'for';
FOREACH    : 'foreach';
FORMAT     : 'format';
FORTIME   : 'fortime';
FROM       : 'from';
FUNC       : 'func';
GET        : 'get';
IF         : 'if';
IMPORT     : 'import';
INHERIT    : 'inherit';
INT        : 'int';
INTERFACE  : 'interface';
LIST       : 'list';
MILLISEC   : 'millisec';
MODULE     : 'module';
NULL       : 'null';
OVERRIDE   : 'override';
PRIVATE    : 'private';
PROTECTED  : 'protected';
PUBLIC     : 'public';
RECUR      : 'recur';
REF        : 'ref';
RETURN     : 'return';
REPEAT     : 'repeat';
SECOND     : 'second';
SET        : 'set';
STATIC     : 'static';
STRING     : 'string';
STRUCT     : 'struct';
SWITCH     : 'switch';
THIS       : 'this';
THROW      : 'throw';
TIME       : 'time';
TRUE       : 'true';
TRY        : 'try';
VIRTUAL    : 'virtual';
VOID       : 'void';
WHILE      : 'while';
WHERE      : 'where';

LEFT_ANGLED_BRACKET: '<';
RIGHT_ANGLED_BRACKET: '>';
LEFT_BRACKET: '[';
RIGHT_BRACKET: ']';
COLON: ':';
COMMA: ',';
LEFT_BRACE: '{';
RIGHT_BRACE: '}';
EQUALS: '=';
LEFT_PAREN: '(';
RIGHT_PAREN: ')';
DELIM_FUNC_RETURN: '->';
SEMICOLON: ';';

UNDERSCORE : '_' ;
OP_EQUALITY: EQUALS;
INHERITS: COLON | INHERIT;

statement
    : IF ELSE IF ELSE SEMICOLON
    | IF ELSE SEMICOLON
    ;

identifier
    : ALPHA+
    ;

block
    : statement
    ;

classBody
    : block
    | LEFT_BRACE block RIGHT_BRACE
    ;

classHeading
    : PUBLIC CLASS identifier LEFT_BRACE classBody RIGHT_BRACE
    ;


functionHeading
    : FUNC identifier functionParameters functionBody
    | FUNC identifier functionParameters functionReturn functionBody
    ;

programStatement
    : functionHeading
    | moduleHeading
    | classHeading
    ;

functionBody
    : LEFT_BRACE RIGHT_BRACE
    | LEFT_BRACE block RIGHT_BRACE
    ;

mainFunction
    : FUNC identifier LEFT_PAREN RIGHT_PAREN functionBody
    ;

value
    : 'a'
    ;
    
STRING_LITERAL
    : '"' ALPHA+ '"'
    ;
    
dataType
    : INT | BOOL | FLOAT | DOUBLE | STRING
    ;

parameter
    : dataType identifier
    | dataType identifier (EQUALS value)
    ;
    
expression
    : value
    | identifier
    | STRING_LITERAL
    ;
    
accessModifier
    : PUBLIC | PRIVATE | PROTECTED
    ;

secondaryModifier
    : VIRTUAL | ABSTRACT | OVERRIDE
    ;

functionModifier
    : REPEAT | DELAYED | ASYNC
    ;

modifier
    : accessModifier
    | accessModifier secondaryModifier
    ;

functionReturn
    : DELIM_FUNC_RETURN dataType
    ;

functionParameters
    : LEFT_PAREN (parameter (COMMA parameter)*)? RIGHT_PAREN
    ;

moduleBody
    : LEFT_BRACE classHeading* RIGHT_BRACE
    ;

moduleHeading
    : MODULE identifier moduleBody
    ;

variableDeclaration
    : modifier? dataType identifier SEMICOLON
    | modifier? dataType identifier OP_EQUALITY expression SEMICOLON
    ;

// parameter
//     : dataType identifier (EQUALS constant)?
//     ;


typeParameters
    : LEFT_ANGLED_BRACKET (dataType (COMMA dataType)*)? RIGHT_ANGLED_BRACKET
    ;

recurLastParameter
    : TIME identifier
    | INT identifier
    ;

recurParameters
    : LEFT_PAREN parameter+ (COMMA parameter)+ recurLastParameter RIGHT_PAREN
    | LEFT_PAREN parameter (COMMA parameter)+ COMMA recurLastParameter RIGHT_PAREN
    ;

recurHeading
    : modifier? ASYNC?
    RECUR identifier typeParameters? recurParameters functionReturn? functionBody
    ;

arguments
    : expression+
    ;

functionCall
    : identifier LEFT_PAREN arguments? RIGHT_PAREN
    ;

structBody
    : LEFT_BRACE RIGHT_BRACE
    ;

structHeading
    : modifier?
    STRUCT identifier structBody
    ;

enumBody
    : LEFT_BRACE (identifier (COMMA identifier)*)? RIGHT_BRACE
    ;

enumHeading
    : modifier?
    ENUM identifier enumBody
    ;

eventBody
    : LEFT_BRACE dataType* RIGHT_BRACE
    ;
 
eventHeading
    : modifier?
    EVENT identifier eventBody
    ;

classBodyDeclarations
    : variableDeclaration
    | functionHeading
    | classHeading
    | structHeading
    | enumHeading
    | eventHeading
    ;


// classHeading
//     : modifier? CLASS typeParameters? identifier (INHERIT identifier)? interfaceSignature? classBody
//     ;

interfaceSignature
    : LEFT_BRACE identifier (COMMA identifier)* RIGHT_PAREN
    ;

keyword
    : ABSTRACT    | ALIAS       | BASE        | BOOL        | BREAK
    | CASE        | CATCH       | CHAR       | CLASS       | CONST
    | CONST       | CONTINUE    | DEFAULT    | DICT        
    | DO          | DOUBLE      | ELSE       | ENUM        
    | EVENT       | FALSE       | FLOAT      | FOR         | FOREACH
    | FORMAT      | FORTIME     | FROM       | FUNC        | GET
    | IF          | IMPORT      | INHERIT    | INT         | INTERFACE
    | LIST        | MILLISEC    | MODULE     | NULL        | OVERRIDE
    | PRIVATE     | PROTECTED   | PUBLIC     | RECUR       | REF
    | RETURN      | SECOND      | SET        | STATIC      | STRING
    | STRUCT      | SWITCH      | THIS       | THROW       | TIME
    | TRUE        | TRY         | VIRTUAL    | VOID        | WHILE
    | WHERE
    ;

operator
    :
    ;

token
    : identifier
    | keyword
    | operator
    ;