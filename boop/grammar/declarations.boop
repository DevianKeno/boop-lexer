value
    : 
    ;
    
STRING_LITERAL
    : DOLLAR
    ;
    
dataType
    : INT | BOOL | FLOAT | DOUBLE | STRING
    ;

parameter
    : dataType IDENTIFIER
    | dataType IDENTIFIER (EQUALS value)
    ;
    
expression
    : value
    | IDENTIFIER
    | STRING_LITERAL
    ;
    
accessModifier
    : PUBLIC | PRIVATE | PROTECTED
    ;

secondaryModifier
    : VIRTUAL | ABSTRACT | OVERRIDE
    ;

functionModifier
    : REPEAT | DELAYED | ASYNC
    ;

modifier
    : accessModifier
    | accessModifier secondaryModifier
    ;

functionReturn
    : DELIM_FUNC_RETURN dataType
    ;

block
    : IF ELSE IF ELSE
    ;
    
mainFunction
    : FUNC IDENTIFIER LEFT_PAREN RIGHT_PAREN functionBody
    ;

functionBody
    : LEFT_BRACE RIGHT_BRACE
    | LEFT_BRACE block RIGHT_BRACE
    ;

functionParameters
    : LEFT_PAREN (parameter (COMMA parameter)*)? RIGHT_PAREN
    ;

functionHeading
    : FUNC IDENTIFIER functionParameters functionReturn functionBody
    ;

classHeading
    : PUBLIC CLASS IDENTIFIER LEFT_BRACE functionHeading RIGHT_BRACE
    ;

moduleBody
    : LEFT_BRACE classHeading* RIGHT_BRACE
    ;

moduleHeading
    : MODULE IDENTIFIER moduleBody
    ;
    
programStatement
    : mainFunction
    | moduleHeading
    | classHeading
    ;

variableDeclaration
    : modifier? dataType IDENTIFIER SEMICOLON
    | modifier? dataType IDENTIFIER OP_EQUALITY expression SEMICOLON
    ;

statement
    : expression+
    ;

// parameter
//     : dataType IDENTIFIER (EQUALS constant)?
//     ;


typeParameters
    : LEFT_ANGLED_BRACKET (dataType (COMMA dataType)*)? RIGHT_ANGLED_BRACKET
    ;

recurLastParameter
    : TIME IDENTIFIER
    | INT IDENTIFIER
    ;

recurParameters
    : LEFT_PAREN parameter+ (COMMA parameter)+ recurLastParameter RIGHT_PAREN
    | LEFT_PAREN parameter (COMMA parameter)+ COMMA recurLastParameter RIGHT_PAREN
    ;

recurHeading
    : modifier? ASYNC?
    RECUR IDENTIFIER typeParameters? recurParameters functionReturn? functionBody
    ;

arguments
    : expression+
    ;

functionCall
    : IDENTIFIER LEFT_PAREN arguments? RIGHT_PAREN
    ;

structBody
    : LEFT_BRACE RIGHT_BRACE
    ;

structHeading
    : modifier?
    STRUCT IDENTIFIER structBody
    ;

enumBody
    : LEFT_BRACE (IDENTIFIER (COMMA IDENTIFIER)*)? RIGHT_BRACE
    ;

enumHeading
    : modifier?
    ENUM IDENTIFIER enumBody
    ;

eventBody
    : LEFT_BRACE dataType* RIGHT_BRACE
    ;
 
eventHeading
    : modifier?
    EVENT IDENTIFIER eventBody
    ;

classBodyDeclarations
    : variableDeclaration
    | functionHeading
    | classHeading
    | structHeading
    | enumHeading
    | eventHeading
    ;

classBody
    : LEFT_BRACE classBodyDeclarations* RIGHT_BRACE
    ;

// classHeading
//     : modifier? CLASS typeParameters? IDENTIFIER (INHERIT IDENTIFIER)? interfaceSignature? classBody
//     ;

interfaceSignature
    : LEFT_BRACE IDENTIFIER (COMMA IDENTIFIER)* RIGHT_PAREN
    ;

keyword
    : ABSTRACT    | ALIAS       | ALIAS      | BASE        | BOOL        | BREAK
    | CASE        | CATCH       | CHAR       | CLASS       | CONST
    | CONST       | CONTINUE    | DEFAULT    | DICT        
    | DO          | DOUBLE      | ELSE       | ENUM        
    | EVENT       | FALSE       | FLOAT      | FOR         | FOREACH
    | FORMAT      | FORTIME     | FROM       | FUNC        | GET
    | IF          | IMPORT      | INHERIT    | INT         | INTERFACE
    | LIST        | MILLISEC    | MODULE     | NULL        | OVERRIDE
    | PRIVATE     | PROTECTED   | PUBLIC     | RECUR       | REF
    | RETURN      | SECOND      | SET        | STATIC      | STRING
    | STRUCT      | SWITCH      | THIS       | THROW       | TIME
    | TRUE        | TRY         | VIRTUAL    | VOID        | WHILE
    | WHERE
    ;

operator
    :
    ;

token
    : IDENTIFIER
    | keyword
    | operator
    ;

#endregion